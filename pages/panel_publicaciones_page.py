
# pages/panel_publicaciones_page.py
import streamlit as st
import sys
from pathlib import Path
from datetime import datetime
from typing import Dict

# --- Configuraci√≥n de la Ruta del Proyecto ---
project_root = str(Path(__file__).resolve().parent.parent)
if project_root not in sys.path:
    sys.path.append(project_root)

from utils.database_manager import DatabaseManager

# --- Funci√≥n Principal de la P√°gina ---
def render_panel_publicaciones(app_config: Dict):
    # Importar la versi√≥n mejorada
    try:
        import sys
        from pathlib import Path
        sys.path.append(str(Path(__file__).parent.parent))
        from tmp_rovodev_enhanced_publications import render_enhanced_panel_publicaciones
        
        # Usar la versi√≥n mejorada
        render_enhanced_panel_publicaciones(app_config)
        return
    except ImportError:
        pass
    
    # Fallback a la versi√≥n original
    st.title("üóìÔ∏è Panel de Publicaciones")
    st.markdown("""
    Aqu√≠ puedes planificar, generar y gestionar el estado de tus v√≠deos para cada canal.
    """)

    # --- Inicializaci√≥n del Gestor de Base de Datos ---
    @st.cache_resource
    def get_db_manager():
        return DatabaseManager()
    
    db_manager = get_db_manager()



    # --- Formulario para Crear Nueva Publicaci√≥n ---
    st.subheader("‚ûï Crear Nueva Publicaci√≥n")
    canales = db_manager.get_all_canales()

    if not canales:
        st.warning("No hay canales disponibles. Por favor, a√±ade canales en la secci√≥n 'Gesti√≥n de Canales'.")
        return

    canal_options = {c['nombre']: c['id'] for c in canales}

    with st.form("nueva_publicacion_form", clear_on_submit=True):
        col_form1, col_form2 = st.columns([2, 1])
        
        with col_form1:
            titulo = st.text_input("üìù T√≠tulo del Video", placeholder="Ej: La vida de Santa Teresa de √Åvila")
            contexto = st.text_area("üéØ Contexto/Tema", placeholder="Describe brevemente el tema del video", height=100)
        
        with col_form2:
            selected_canal_name = st.selectbox("üì∫ Canal", list(canal_options.keys()))
            script_type = st.selectbox(
                "ü§ñ Tipo de Gui√≥n",
                ["‚úçÔ∏è Gui√≥n Manual", "ü§ñ Generar con IA"],
                help="Manual: Escribes el gui√≥n completo. IA: Se genera autom√°ticamente desde el contexto."
            )
        
        # Mostrar campo de gui√≥n solo si es manual
        if script_type == "‚úçÔ∏è Gui√≥n Manual":
            guion = st.text_area("üìú Gui√≥n del Video", placeholder="Escribe aqu√≠ el gui√≥n completo del video...", height=200)
        else:
            guion = ""  # Para IA, el gui√≥n se genera autom√°ticamente
            st.info("ü§ñ **Modo IA activado**: El gui√≥n se generar√° autom√°ticamente basado en el contexto/tema que escribas arriba.")
        
        submitted = st.form_submit_button("‚ûï Crear Publicaci√≥n", type="primary")
        
        if submitted:
            if not titulo.strip():
                st.error("‚ùå El t√≠tulo es obligatorio")
            elif not contexto.strip():
                st.error("‚ùå El contexto/tema es obligatorio")
            elif script_type == "‚úçÔ∏è Gui√≥n Manual" and not guion.strip():
                st.error("‚ùå El gui√≥n es obligatorio para modo manual")
            else:
                id_canal = canal_options[selected_canal_name]
                script_type_db = 'manual' if script_type == "‚úçÔ∏è Gui√≥n Manual" else 'ai'
                
                new_id = db_manager.add_publicacion(
                    titulo.strip(), 
                    guion.strip() if script_type == "‚úçÔ∏è Gui√≥n Manual" else "", 
                    contexto.strip(), 
                    id_canal, 
                    script_type_db
                )
                if new_id:
                    modo_texto = "con gui√≥n manual" if script_type_db == 'manual' else "con generaci√≥n por IA"
                    st.success(f"‚úÖ Publicaci√≥n '{titulo}' creada para '{selected_canal_name}' {modo_texto}.")
                    st.rerun() # Recargar para mostrar la nueva publicaci√≥n
                else:
                    st.error("‚ùå Hubo un error al crear la publicaci√≥n.")

    # --- Mostrar estado del Batch Processor ---
    if "batch_projects" in st.session_state and st.session_state.batch_projects:
        cms_projects_in_batch = [p for p in st.session_state.batch_projects if "cms_publicacion_id" in p]
        if cms_projects_in_batch:
            st.info(f"üöÄ **{len(cms_projects_in_batch)} video(s) del CMS** en cola del Batch Processor. Ve a la pesta√±a 'Batch Processor' para procesarlos.")

    # --- Mostrar la Lista de Publicaciones ---
    st.header("Mis Publicaciones")

    publicaciones = db_manager.get_all_publicaciones_info()
    
    if not publicaciones:
        st.info("A√∫n no hay publicaciones planificadas. ¬°Usa el formulario de arriba para empezar!")
    else:
        # Preparar datos para tabla estilo Excel
        import pandas as pd
        
        # Convertir a DataFrame para mejor manipulaci√≥n
        df = pd.DataFrame(publicaciones)
        
        # A√±adir iconos de estado
        status_icons = {
            'Pendiente': '‚è≥ Pendiente',
            'En Batch': 'üöÄ En Batch',
            'Generando': '‚öôÔ∏è Generando',
            'Generado': '‚úÖ Generado',
            'Subido': 'üì∫ Subido',
            'Error': '‚ùå Error'
        }
        df['estado_visual'] = df['status'].map(status_icons)
        
        # A√±adir iconos de tipo de script
        script_icons = {
            'manual': '‚úçÔ∏è Manual',
            'ai': 'ü§ñ IA'
        }
        df['script_visual'] = df['script_type'].map(script_icons)
        
        # Formatear fechas para mejor visualizaci√≥n
        if 'fecha_planificacion' in df.columns:
            df['fecha_planificacion'] = pd.to_datetime(df['fecha_planificacion']).dt.strftime('%d/%m/%Y %H:%M')
        if 'fecha_subida' in df.columns:
            df['fecha_subida'] = pd.to_datetime(df['fecha_subida'], errors='coerce').dt.strftime('%d/%m/%Y %H:%M')
        
        # Crear tabla estilo Excel con st.data_editor
        edited_df = st.data_editor(
            df,
            column_config={
                "id": st.column_config.NumberColumn("ID", width="small", disabled=True),
                "titulo": st.column_config.TextColumn("üìù T√≠tulo del Video", width="large", disabled=True),
                "script_visual": st.column_config.TextColumn("ü§ñ Tipo", width="small", disabled=True),
                "nombre_canal": st.column_config.TextColumn("üì∫ Canal", width="medium", disabled=True),
                "estado_visual": st.column_config.TextColumn("üìä Estado", width="medium", disabled=True),
                "fecha_planificacion": st.column_config.TextColumn("üìÖ Planificado", width="medium", disabled=True),
                "fecha_subida": st.column_config.TextColumn("üì§ Subido", width="medium", disabled=True),
                "ruta_proyecto": st.column_config.TextColumn("üìÅ Proyecto", width="large", disabled=True),
                # Ocultar columnas t√©cnicas y de contenido
                "id_canal": None,
                "status": None,
                "script_type": None,
                "guion": None,
                "contexto": None,
            },
            hide_index=True,
            use_container_width=True,
            key="publicaciones_table"
        )
        
        # Botones de acci√≥n debajo de la tabla
        st.subheader("üé¨ Acciones R√°pidas")
        
        # Selector para acciones
        col1, col2, col3 = st.columns(3)
        
        with col1:
            # Obtener publicaciones pendientes
            pendientes = [p for p in publicaciones if p['status'] == 'Pendiente']
            if pendientes:
                st.markdown("**üöÄ Enviar al Batch**")
                selected_pendiente = st.selectbox(
                    "Selecciona publicaci√≥n pendiente:",
                    options=[f"{p['id']} - {p['titulo']}" for p in pendientes],
                    key="select_pendiente"
                )
                
                if st.button("üöÄ Enviar al Batch Processor", key="batch_action"):
                    pub_id = int(selected_pendiente.split(' - ')[0])
                    pub = next(p for p in publicaciones if p['id'] == pub_id)
                    
                    # Inicializar batch_projects si no existe
                    if "batch_projects" not in st.session_state:
                        st.session_state.batch_projects = []
                    
                    # Crear proyecto para el batch processor
                    import uuid
                    from datetime import datetime
                    
                    # Determinar tipo de script para el batch processor
                    batch_script_type = "‚úçÔ∏è Usar gui√≥n manual" if pub['script_type'] == 'manual' else "ü§ñ Generar con IA"
                    
                    nuevo_proyecto_batch = {
                        "titulo": pub['titulo'],
                        "contexto": pub['contexto'],
                        "script_type": batch_script_type,
                        "guion_manual": pub['guion'] if pub['script_type'] == 'manual' else None,
                        "id": str(uuid.uuid4())[:8],
                        "fecha_a√±adido": datetime.now().isoformat(),
                        "cms_publicacion_id": pub['id'],
                        "cms_canal": pub['nombre_canal']
                    }
                    
                    st.session_state.batch_projects.append(nuevo_proyecto_batch)
                    db_manager.update_publicacion_status(pub['id'], 'En Batch')
                    
                    st.success(f"‚úÖ '{pub['titulo']}' enviado al Batch!")
                    st.rerun()
            else:
                st.info("No hay publicaciones pendientes")
        
        with col2:
            # Publicaciones generadas listas para marcar como subidas
            generados = [p for p in publicaciones if p['status'] == 'Generado']
            if generados:
                st.markdown("**‚úÖ Marcar como Subido**")
                selected_generado = st.selectbox(
                    "Selecciona publicaci√≥n generada:",
                    options=[f"{p['id']} - {p['titulo']}" for p in generados],
                    key="select_generado"
                )
                
                if st.button("‚úÖ Marcar como Subido", key="upload_action"):
                    pub_id = int(selected_generado.split(' - ')[0])
                    db_manager.update_publicacion_status(pub_id, 'Subido')
                    st.success("‚úÖ Publicaci√≥n marcada como subida!")
                    st.rerun()
            else:
                st.info("No hay publicaciones generadas")
        
        with col3:
            # Publicaciones con error para reintentar
            errores = [p for p in publicaciones if p['status'] == 'Error']
            if errores:
                st.markdown("**üîÑ Reintentar Errores**")
                selected_error = st.selectbox(
                    "Selecciona publicaci√≥n con error:",
                    options=[f"{p['id']} - {p['titulo']}" for p in errores],
                    key="select_error"
                )
                
                if st.button("üîÑ Reintentar", key="retry_action"):
                    pub_id = int(selected_error.split(' - ')[0])
                    db_manager.update_publicacion_status(pub_id, 'Pendiente')
                    st.success("üîÑ Estado cambiado a 'Pendiente'")
                    st.rerun()
            else:
                st.info("No hay publicaciones con error")
        
        # Secci√≥n de eliminaci√≥n con confirmaci√≥n
        st.subheader("üóëÔ∏è Eliminar Publicaciones")
        
        # Dividir en dos columnas para la eliminaci√≥n
        col_del1, col_del2 = st.columns(2)
        
        with col_del1:
            st.markdown("**‚ö†Ô∏è Eliminar Publicaci√≥n**")
            
            # Crear mapeo de estado para mostrar iconos
            status_icons = {
                'Pendiente': '‚è≥ Pendiente',
                'En Batch': 'üöÄ En Batch',
                'Generando': '‚öôÔ∏è Generando',
                'Generado': '‚úÖ Generado',
                'Subido': 'üì∫ Subido',
                'Error': '‚ùå Error'
            }
            
            selected_to_delete = st.selectbox(
                "Selecciona publicaci√≥n a eliminar:",
                options=[f"{p['id']} - {p['titulo']} ({status_icons.get(p['status'], p['status'])})" for p in publicaciones],
                key="select_delete"
            )
        
        with col_del2:
            st.markdown("**Confirmaci√≥n requerida**")
            confirmar_eliminacion = st.checkbox("‚úÖ Confirmo que quiero eliminar esta publicaci√≥n", key="confirm_delete")
            
            if st.button("üóëÔ∏è ELIMINAR PUBLICACI√ìN", key="delete_action", type="secondary"):
                if confirmar_eliminacion:
                    pub_id = int(selected_to_delete.split(' - ')[0])
                    success = db_manager.delete_publicacion(pub_id)
                    if success:
                        # Tambi√©n eliminar del batch processor si est√° ah√≠
                        if "batch_projects" in st.session_state:
                            st.session_state.batch_projects = [
                                p for p in st.session_state.batch_projects 
                                if p.get("cms_publicacion_id") != pub_id
                            ]
                        st.success("üóëÔ∏è Publicaci√≥n eliminada exitosamente!")
                        st.rerun()
                    else:
                        st.error("‚ùå Error al eliminar la publicaci√≥n")
                else:
                    st.warning("‚ö†Ô∏è Marca la casilla de confirmaci√≥n para eliminar")
        
        # Resumen estad√≠stico
        st.subheader("üìä Resumen")
        col_stats1, col_stats2, col_stats3, col_stats4 = st.columns(4)
        
        with col_stats1:
            pendientes_count = len([p for p in publicaciones if p['status'] == 'Pendiente'])
            st.metric("‚è≥ Pendientes", pendientes_count)
        
        with col_stats2:
            en_batch_count = len([p for p in publicaciones if p['status'] in ['En Batch', 'Generando']])
            st.metric("üöÄ En Proceso", en_batch_count)
        
        with col_stats3:
            generados_count = len([p for p in publicaciones if p['status'] == 'Generado'])
            st.metric("‚úÖ Generados", generados_count)
        
        with col_stats4:
            subidos_count = len([p for p in publicaciones if p['status'] == 'Subido'])
            st.metric("üì∫ Subidos", subidos_count)

    # --- Nota al pie ---
    st.markdown("--- ")
    st.info("üéØ **Flujo de trabajo integrado:** Este panel te permite gestionar el ciclo de vida de tus v√≠deos. Los videos se env√≠an autom√°ticamente al Batch Processor para aprovechar todas sus funcionalidades avanzadas de configuraci√≥n, IA, efectos y monitoreo de progreso.")

# --- Ejecuci√≥n directa para pruebas (opcional) ---
if __name__ == "__main__":
    render_panel_publicaciones()
